{"version":3,"sources":["webpack:///../../../src/directives/ripple/index.ts","webpack:///../../../src/directives/intersect/index.ts","webpack:///../../../src/directives/click-outside/index.ts","webpack:///../../../src/directives/touch/index.ts","webpack:///../../../src/directives/resize/index.ts","webpack:///../src/install.ts","webpack:///../src/framework.ts","webpack:///../../../src/directives/scroll/index.ts"],"names":["DELAY_RIPPLE","transform","el","opacity","value","isTouchEvent","e","isKeyboardEvent","calculate","localX","localY","offset","target","radius","scale","Math","centerX","centerY","x","y","ripples","show","container","document","animation","size","computed","window","String","performance","setTimeout","hide","diff","Number","delay","isRippleEnabled","rippleShow","element","rippleHide","rippleCancelShow","keyboardRipple","keyboardRippleShow","keyboardRippleHide","updateRipple","enabled","binding","passive","removeListeners","directive","unbind","update","wasEnabled","Ripple","bind","inserted","modifiers","handler","options","observer","IntersectionObserver","entries","isIntersecting","Boolean","entry","init","observe","Intersect","defaultConditional","isActive","elements","ClickOutside","onClick","app","handleGesture","wrapper","touchendY","dirRatio","minDistance","touchendX","touchstartX","touchstartY","touch","event","Object","createHandlers","touchmoveX","touchmoveY","offsetX","offsetY","left","right","up","down","start","move","end","touchstart","touchend","touchmove","handlers","vnode","eventName","Touch","callback","Resize","args","install","console","components","directives","Vue","registerComponents","component","beforeCreate","this","userPreset","framework","installed","preset","property","service","Service","includes","version","config","silent","self","undefined","Scroll"],"mappings":"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","file":"js/chunk-vendors~85da75cb.7e319f8c.js","sourcesContent":["// Styles\nimport './VRipple.sass'\n\n// Utilities\nimport { consoleWarn } from '../../util/console'\nimport { keyCodes } from '../../util/helpers'\n\n// Types\nimport { VNode, VNodeDirective } from 'vue'\n\ntype VuetifyRippleEvent = MouseEvent | TouchEvent | KeyboardEvent\n\nconst DELAY_RIPPLE = 80\n\nfunction transform (el: HTMLElement, value: string) {\n  el.style['transform'] = value\n  el.style['webkitTransform'] = value\n}\n\nfunction opacity (el: HTMLElement, value: number) {\n  el.style['opacity'] = value.toString()\n}\n\nexport interface RippleOptions {\n  class?: string\n  center?: boolean\n  circle?: boolean\n}\n\nfunction isTouchEvent (e: VuetifyRippleEvent): e is TouchEvent {\n  return e.constructor.name === 'TouchEvent'\n}\n\nfunction isKeyboardEvent (e: VuetifyRippleEvent): e is KeyboardEvent {\n  return e.constructor.name === 'KeyboardEvent'\n}\n\nconst calculate = (\n  e: VuetifyRippleEvent,\n  el: HTMLElement,\n  value: RippleOptions = {}\n) => {\n  let localX = 0\n  let localY = 0\n\n  if (!isKeyboardEvent(e)) {\n    const offset = el.getBoundingClientRect()\n    const target = isTouchEvent(e) ? e.touches[e.touches.length - 1] : e\n\n    localX = target.clientX - offset.left\n    localY = target.clientY - offset.top\n  }\n\n  let radius = 0\n  let scale = 0.3\n  if (el._ripple && el._ripple.circle) {\n    scale = 0.15\n    radius = el.clientWidth / 2\n    radius = value.center ? radius : radius + Math.sqrt((localX - radius) ** 2 + (localY - radius) ** 2) / 4\n  } else {\n    radius = Math.sqrt(el.clientWidth ** 2 + el.clientHeight ** 2) / 2\n  }\n\n  const centerX = `${(el.clientWidth - (radius * 2)) / 2}px`\n  const centerY = `${(el.clientHeight - (radius * 2)) / 2}px`\n\n  const x = value.center ? centerX : `${localX - radius}px`\n  const y = value.center ? centerY : `${localY - radius}px`\n\n  return { radius, scale, x, y, centerX, centerY }\n}\n\nconst ripples = {\n  /* eslint-disable max-statements */\n  show (\n    e: VuetifyRippleEvent,\n    el: HTMLElement,\n    value: RippleOptions = {}\n  ) {\n    if (!el._ripple || !el._ripple.enabled) {\n      return\n    }\n\n    const container = document.createElement('span')\n    const animation = document.createElement('span')\n\n    container.appendChild(animation)\n    container.className = 'v-ripple__container'\n\n    if (value.class) {\n      container.className += ` ${value.class}`\n    }\n\n    const { radius, scale, x, y, centerX, centerY } = calculate(e, el, value)\n\n    const size = `${radius * 2}px`\n    animation.className = 'v-ripple__animation'\n    animation.style.width = size\n    animation.style.height = size\n\n    el.appendChild(container)\n\n    const computed = window.getComputedStyle(el)\n    if (computed && computed.position === 'static') {\n      el.style.position = 'relative'\n      el.dataset.previousPosition = 'static'\n    }\n\n    animation.classList.add('v-ripple__animation--enter')\n    animation.classList.add('v-ripple__animation--visible')\n    transform(animation, `translate(${x}, ${y}) scale3d(${scale},${scale},${scale})`)\n    opacity(animation, 0)\n    animation.dataset.activated = String(performance.now())\n\n    setTimeout(() => {\n      animation.classList.remove('v-ripple__animation--enter')\n      animation.classList.add('v-ripple__animation--in')\n      transform(animation, `translate(${centerX}, ${centerY}) scale3d(1,1,1)`)\n      opacity(animation, 0.25)\n    }, 0)\n  },\n\n  hide (el: HTMLElement | null) {\n    if (!el || !el._ripple || !el._ripple.enabled) return\n\n    const ripples = el.getElementsByClassName('v-ripple__animation')\n\n    if (ripples.length === 0) return\n    const animation = ripples[ripples.length - 1]\n\n    if (animation.dataset.isHiding) return\n    else animation.dataset.isHiding = 'true'\n\n    const diff = performance.now() - Number(animation.dataset.activated)\n    const delay = Math.max(250 - diff, 0)\n\n    setTimeout(() => {\n      animation.classList.remove('v-ripple__animation--in')\n      animation.classList.add('v-ripple__animation--out')\n      opacity(animation, 0)\n\n      setTimeout(() => {\n        const ripples = el.getElementsByClassName('v-ripple__animation')\n        if (ripples.length === 1 && el.dataset.previousPosition) {\n          el.style.position = el.dataset.previousPosition\n          delete el.dataset.previousPosition\n        }\n\n        animation.parentNode && el.removeChild(animation.parentNode)\n      }, 300)\n    }, delay)\n  },\n}\n\nfunction isRippleEnabled (value: any): value is true {\n  return typeof value === 'undefined' || !!value\n}\n\nfunction rippleShow (e: VuetifyRippleEvent) {\n  const value: RippleOptions = {}\n  const element = e.currentTarget as HTMLElement\n  if (!element || !element._ripple || element._ripple.touched) return\n  if (isTouchEvent(e)) {\n    element._ripple.touched = true\n    element._ripple.isTouch = true\n  } else {\n    // It's possible for touch events to fire\n    // as mouse events on Android/iOS, this\n    // will skip the event call if it has\n    // already been registered as touch\n    if (element._ripple.isTouch) return\n  }\n  value.center = element._ripple.centered || isKeyboardEvent(e)\n  if (element._ripple.class) {\n    value.class = element._ripple.class\n  }\n\n  if (isTouchEvent(e)) {\n    // already queued that shows or hides the ripple\n    if (element._ripple.showTimerCommit) return\n\n    element._ripple.showTimerCommit = () => {\n      ripples.show(e, element, value)\n    }\n    element._ripple.showTimer = window.setTimeout(() => {\n      if (element && element._ripple && element._ripple.showTimerCommit) {\n        element._ripple.showTimerCommit()\n        element._ripple.showTimerCommit = null\n      }\n    }, DELAY_RIPPLE)\n  } else {\n    ripples.show(e, element, value)\n  }\n}\n\nfunction rippleHide (e: Event) {\n  const element = e.currentTarget as HTMLElement | null\n  if (!element || !element._ripple) return\n\n  window.clearTimeout(element._ripple.showTimer)\n\n  // The touch interaction occurs before the show timer is triggered.\n  // We still want to show ripple effect.\n  if (e.type === 'touchend' && element._ripple.showTimerCommit) {\n    element._ripple.showTimerCommit()\n    element._ripple.showTimerCommit = null\n\n    // re-queue ripple hiding\n    element._ripple.showTimer = setTimeout(() => {\n      rippleHide(e)\n    })\n    return\n  }\n\n  window.setTimeout(() => {\n    if (element._ripple) {\n      element._ripple.touched = false\n    }\n  })\n  ripples.hide(element)\n}\n\nfunction rippleCancelShow (e: MouseEvent | TouchEvent) {\n  const element = e.currentTarget as HTMLElement | undefined\n\n  if (!element || !element._ripple) return\n\n  if (element._ripple.showTimerCommit) {\n    element._ripple.showTimerCommit = null\n  }\n\n  window.clearTimeout(element._ripple.showTimer)\n}\n\nlet keyboardRipple = false\n\nfunction keyboardRippleShow (e: KeyboardEvent) {\n  if (!keyboardRipple && (e.keyCode === keyCodes.enter || e.keyCode === keyCodes.space)) {\n    keyboardRipple = true\n    rippleShow(e)\n  }\n}\n\nfunction keyboardRippleHide (e: KeyboardEvent) {\n  keyboardRipple = false\n  rippleHide(e)\n}\n\nfunction updateRipple (el: HTMLElement, binding: VNodeDirective, wasEnabled: boolean) {\n  const enabled = isRippleEnabled(binding.value)\n  if (!enabled) {\n    ripples.hide(el)\n  }\n  el._ripple = el._ripple || {}\n  el._ripple.enabled = enabled\n  const value = binding.value || {}\n  if (value.center) {\n    el._ripple.centered = true\n  }\n  if (value.class) {\n    el._ripple.class = binding.value.class\n  }\n  if (value.circle) {\n    el._ripple.circle = value.circle\n  }\n  if (enabled && !wasEnabled) {\n    el.addEventListener('touchstart', rippleShow, { passive: true })\n    el.addEventListener('touchend', rippleHide, { passive: true })\n    el.addEventListener('touchmove', rippleCancelShow, { passive: true })\n    el.addEventListener('touchcancel', rippleHide)\n\n    el.addEventListener('mousedown', rippleShow)\n    el.addEventListener('mouseup', rippleHide)\n    el.addEventListener('mouseleave', rippleHide)\n\n    el.addEventListener('keydown', keyboardRippleShow)\n    el.addEventListener('keyup', keyboardRippleHide)\n\n    // Anchor tags can be dragged, causes other hides to fail - #1537\n    el.addEventListener('dragstart', rippleHide, { passive: true })\n  } else if (!enabled && wasEnabled) {\n    removeListeners(el)\n  }\n}\n\nfunction removeListeners (el: HTMLElement) {\n  el.removeEventListener('mousedown', rippleShow)\n  el.removeEventListener('touchstart', rippleShow)\n  el.removeEventListener('touchend', rippleHide)\n  el.removeEventListener('touchmove', rippleCancelShow)\n  el.removeEventListener('touchcancel', rippleHide)\n  el.removeEventListener('mouseup', rippleHide)\n  el.removeEventListener('mouseleave', rippleHide)\n  el.removeEventListener('keydown', keyboardRippleShow)\n  el.removeEventListener('keyup', keyboardRippleHide)\n  el.removeEventListener('dragstart', rippleHide)\n}\n\nfunction directive (el: HTMLElement, binding: VNodeDirective, node: VNode) {\n  updateRipple(el, binding, false)\n\n  if (process.env.NODE_ENV === 'development') {\n    // warn if an inline element is used, waiting for el to be in the DOM first\n    node.context && node.context.$nextTick(() => {\n      const computed = window.getComputedStyle(el)\n      if (computed && computed.display === 'inline') {\n        const context = (node as any).fnOptions ? [(node as any).fnOptions, node.context] : [node.componentInstance]\n        consoleWarn('v-ripple can only be used on block-level elements', ...context)\n      }\n    })\n  }\n}\n\nfunction unbind (el: HTMLElement) {\n  delete el._ripple\n  removeListeners(el)\n}\n\nfunction update (el: HTMLElement, binding: VNodeDirective) {\n  if (binding.value === binding.oldValue) {\n    return\n  }\n\n  const wasEnabled = isRippleEnabled(binding.oldValue)\n  updateRipple(el, binding, wasEnabled)\n}\n\nexport const Ripple = {\n  bind: directive,\n  unbind,\n  update,\n}\n\nexport default Ripple\n","import { VNodeDirective } from 'vue/types/vnode'\n\ntype ObserveHandler = (\n  entries: IntersectionObserverEntry[],\n  observer: IntersectionObserver,\n  isIntersecting: boolean,\n) => void\n\ninterface ObserveVNodeDirective extends Omit<VNodeDirective, 'modifiers'> {\n  value?: ObserveHandler | { handler: ObserveHandler, options?: IntersectionObserverInit }\n  modifiers?: {\n    once?: boolean\n    quiet?: boolean\n  }\n}\n\nfunction inserted (el: HTMLElement, binding: ObserveVNodeDirective) {\n  const modifiers = binding.modifiers || {}\n  const value = binding.value\n  const { handler, options } = typeof value === 'object'\n    ? value\n    : { handler: value, options: {} }\n  const observer = new IntersectionObserver((\n    entries: IntersectionObserverEntry[] = [],\n    observer: IntersectionObserver\n  ) => {\n    /* istanbul ignore if */\n    if (!el._observe) return // Just in case, should never fire\n\n    // If is not quiet or has already been\n    // initted, invoke the user callback\n    if (\n      handler && (\n        !modifiers.quiet ||\n        el._observe.init\n      )\n    ) {\n      const isIntersecting = Boolean(entries.find(entry => entry.isIntersecting))\n\n      handler(entries, observer, isIntersecting)\n    }\n\n    // If has already been initted and\n    // has the once modifier, unbind\n    if (el._observe.init && modifiers.once) unbind(el)\n    // Otherwise, mark the observer as initted\n    else (el._observe.init = true)\n  }, options)\n\n  el._observe = { init: false, observer }\n\n  observer.observe(el)\n}\n\nfunction unbind (el: HTMLElement) {\n  /* istanbul ignore if */\n  if (!el._observe) return\n\n  el._observe.observer.unobserve(el)\n  delete el._observe\n}\n\nexport const Intersect = {\n  inserted,\n  unbind,\n}\n\nexport default Intersect\n","import { VNodeDirective } from 'vue/types/vnode'\n\ninterface ClickOutsideBindingArgs {\n  handler: (e: Event) => void\n  closeConditional?: (e: Event) => boolean\n  include?: () => HTMLElement[]\n}\n\ninterface ClickOutsideDirective extends VNodeDirective {\n  value?: ((e: Event) => void) | ClickOutsideBindingArgs\n}\n\nfunction defaultConditional () {\n  return true\n}\n\nfunction directive (e: PointerEvent, el: HTMLElement, binding: ClickOutsideDirective): void {\n  const handler = typeof binding.value === 'function' ? binding.value : binding.value!.handler\n\n  const isActive = (typeof binding.value === 'object' && binding.value.closeConditional) || defaultConditional\n\n  // The include element callbacks below can be expensive\n  // so we should avoid calling them when we're not active.\n  // Explicitly check for false to allow fallback compatibility\n  // with non-toggleable components\n  if (!e || isActive(e) === false) return\n\n  // If click was triggered programmaticaly (domEl.click()) then\n  // it shouldn't be treated as click-outside\n  // Chrome/Firefox support isTrusted property\n  // IE/Edge support pointerType property (empty if not triggered\n  // by pointing device)\n  if (('isTrusted' in e && !e.isTrusted) ||\n    ('pointerType' in e && !e.pointerType)\n  ) return\n\n  // Check if additional elements were passed to be included in check\n  // (click must be outside all included elements, if any)\n  const elements = ((typeof binding.value === 'object' && binding.value.include) || (() => []))()\n  // Add the root element for the component this directive was defined on\n  elements.push(el)\n\n  // Check if it's a click outside our elements, and then if our callback returns true.\n  // Non-toggleable components should take action in their callback and return falsy.\n  // Toggleable can return true if it wants to deactivate.\n  // Note that, because we're in the capture phase, this callback will occur before\n  // the bubbling click event on any outside elements.\n  !elements.some(el => el.contains(e.target as Node)) && setTimeout(() => {\n    isActive(e) && handler && handler(e)\n  }, 0)\n}\n\nexport const ClickOutside = {\n  // [data-app] may not be found\n  // if using bind, inserted makes\n  // sure that the root element is\n  // available, iOS does not support\n  // clicks on body\n  inserted (el: HTMLElement, binding: ClickOutsideDirective) {\n    const onClick = (e: Event) => directive(e as PointerEvent, el, binding)\n    // iOS does not recognize click events on document\n    // or body, this is the entire purpose of the v-app\n    // component and [data-app], stop removing this\n    const app = document.querySelector('[data-app]') ||\n      document.body // This is only for unit tests\n    app.addEventListener('click', onClick, true)\n    el._clickOutside = onClick\n  },\n\n  unbind (el: HTMLElement) {\n    if (!el._clickOutside) return\n\n    const app = document.querySelector('[data-app]') ||\n      document.body // This is only for unit tests\n    app && app.removeEventListener('click', el._clickOutside, true)\n    delete el._clickOutside\n  },\n}\n\nexport default ClickOutside\n","import { VNodeDirective, VNode } from 'vue/types/vnode'\nimport { keys } from '../../util/helpers'\nimport { TouchHandlers, TouchValue, TouchWrapper } from 'vuetify/types'\n\nexport interface TouchStoredHandlers {\n  touchstart: (e: TouchEvent) => void\n  touchend: (e: TouchEvent) => void\n  touchmove: (e: TouchEvent) => void\n}\n\ninterface TouchVNodeDirective extends VNodeDirective {\n  value?: TouchValue\n}\n\nconst handleGesture = (wrapper: TouchWrapper) => {\n  const { touchstartX, touchendX, touchstartY, touchendY } = wrapper\n  const dirRatio = 0.5\n  const minDistance = 16\n  wrapper.offsetX = touchendX - touchstartX\n  wrapper.offsetY = touchendY - touchstartY\n\n  if (Math.abs(wrapper.offsetY) < dirRatio * Math.abs(wrapper.offsetX)) {\n    wrapper.left && (touchendX < touchstartX - minDistance) && wrapper.left(wrapper)\n    wrapper.right && (touchendX > touchstartX + minDistance) && wrapper.right(wrapper)\n  }\n\n  if (Math.abs(wrapper.offsetX) < dirRatio * Math.abs(wrapper.offsetY)) {\n    wrapper.up && (touchendY < touchstartY - minDistance) && wrapper.up(wrapper)\n    wrapper.down && (touchendY > touchstartY + minDistance) && wrapper.down(wrapper)\n  }\n}\n\nfunction touchstart (event: TouchEvent, wrapper: TouchWrapper) {\n  const touch = event.changedTouches[0]\n  wrapper.touchstartX = touch.clientX\n  wrapper.touchstartY = touch.clientY\n\n  wrapper.start &&\n    wrapper.start(Object.assign(event, wrapper))\n}\n\nfunction touchend (event: TouchEvent, wrapper: TouchWrapper) {\n  const touch = event.changedTouches[0]\n  wrapper.touchendX = touch.clientX\n  wrapper.touchendY = touch.clientY\n\n  wrapper.end &&\n    wrapper.end(Object.assign(event, wrapper))\n\n  handleGesture(wrapper)\n}\n\nfunction touchmove (event: TouchEvent, wrapper: TouchWrapper) {\n  const touch = event.changedTouches[0]\n  wrapper.touchmoveX = touch.clientX\n  wrapper.touchmoveY = touch.clientY\n\n  wrapper.move && wrapper.move(Object.assign(event, wrapper))\n}\n\nfunction createHandlers (value: TouchHandlers): TouchStoredHandlers {\n  const wrapper = {\n    touchstartX: 0,\n    touchstartY: 0,\n    touchendX: 0,\n    touchendY: 0,\n    touchmoveX: 0,\n    touchmoveY: 0,\n    offsetX: 0,\n    offsetY: 0,\n    left: value.left,\n    right: value.right,\n    up: value.up,\n    down: value.down,\n    start: value.start,\n    move: value.move,\n    end: value.end,\n  }\n\n  return {\n    touchstart: (e: TouchEvent) => touchstart(e, wrapper),\n    touchend: (e: TouchEvent) => touchend(e, wrapper),\n    touchmove: (e: TouchEvent) => touchmove(e, wrapper),\n  }\n}\n\nfunction inserted (el: HTMLElement, binding: TouchVNodeDirective, vnode: VNode) {\n  const value = binding.value!\n  const target = value.parent ? el.parentElement : el\n  const options = value.options || { passive: true }\n\n  // Needed to pass unit tests\n  if (!target) return\n\n  const handlers = createHandlers(binding.value!)\n  target._touchHandlers = Object(target._touchHandlers)\n  target._touchHandlers![vnode.context!._uid] = handlers\n\n  keys(handlers).forEach(eventName => {\n    target.addEventListener(eventName, handlers[eventName] as EventListener, options)\n  })\n}\n\nfunction unbind (el: HTMLElement, binding: TouchVNodeDirective, vnode: VNode) {\n  const target = binding.value!.parent ? el.parentElement : el\n  if (!target || !target._touchHandlers) return\n\n  const handlers = target._touchHandlers[vnode.context!._uid]\n  keys(handlers).forEach(eventName => {\n    target.removeEventListener(eventName, handlers[eventName])\n  })\n  delete target._touchHandlers[vnode.context!._uid]\n}\n\nexport const Touch = {\n  inserted,\n  unbind,\n}\n\nexport default Touch\n","import { VNodeDirective } from 'vue/types/vnode'\n\ninterface ResizeVNodeDirective extends VNodeDirective {\n  value?: () => void\n  options?: boolean | AddEventListenerOptions\n}\n\nfunction inserted (el: HTMLElement, binding: ResizeVNodeDirective) {\n  const callback = binding.value!\n  const options = binding.options || { passive: true }\n\n  window.addEventListener('resize', callback, options)\n  el._onResize = {\n    callback,\n    options,\n  }\n\n  if (!binding.modifiers || !binding.modifiers.quiet) {\n    callback()\n  }\n}\n\nfunction unbind (el: HTMLElement) {\n  if (!el._onResize) return\n\n  const { callback, options } = el._onResize\n  window.removeEventListener('resize', callback, options)\n  delete el._onResize\n}\n\nexport const Resize = {\n  inserted,\n  unbind,\n}\n\nexport default Resize\n","import OurVue, { VueConstructor } from 'vue'\nimport { VuetifyUseOptions } from 'vuetify/types'\nimport { consoleError } from './util/console'\n\nexport function install (Vue: VueConstructor, args: VuetifyUseOptions = {}) {\n  if ((install as any).installed) return\n  (install as any).installed = true\n\n  if (OurVue !== Vue) {\n    consoleError('Multiple instances of Vue detected\\nSee https://github.com/vuetifyjs/vuetify/issues/4068\\n\\nIf you\\'re seeing \"$attrs is readonly\", it\\'s caused by this')\n  }\n\n  const components = args.components || {}\n  const directives = args.directives || {}\n\n  for (const name in directives) {\n    const directive = directives[name]\n\n    Vue.directive(name, directive)\n  }\n\n  (function registerComponents (components: any) {\n    if (components) {\n      for (const key in components) {\n        const component = components[key]\n        if (component && !registerComponents(component.$_vuetify_subcomponents)) {\n          Vue.component(key, component as typeof Vue)\n        }\n      }\n      return true\n    }\n    return false\n  })(components)\n\n  // Used to avoid multiple mixins being setup\n  // when in dev mode and hot module reload\n  // https://github.com/vuejs/vue/issues/5089#issuecomment-284260111\n  if (Vue.$_vuetify_installed) return\n  Vue.$_vuetify_installed = true\n\n  Vue.mixin({\n    beforeCreate () {\n      const options = this.$options as any\n\n      if (options.vuetify) {\n        options.vuetify.init(this, options.ssrContext)\n        this.$vuetify = Vue.observable(options.vuetify.framework)\n      } else {\n        this.$vuetify = (options.parent && options.parent.$vuetify) || this\n      }\n    },\n  })\n}\n","import { install } from './install'\n\n// Types\nimport Vue from 'vue'\nimport {\n  UserVuetifyPreset,\n  VuetifyPreset,\n} from 'vuetify/types/services/presets'\nimport {\n  VuetifyService,\n  VuetifyServiceContract,\n} from 'vuetify/types/services'\n\n// Services\nimport * as services from './services'\n\nexport default class Vuetify {\n  static install = install\n\n  static installed = false\n\n  static version = __VUETIFY_VERSION__\n\n  static config = {\n    silent: false,\n  }\n\n  public framework: Dictionary<VuetifyServiceContract> = {}\n\n  public installed: string[] = []\n\n  public preset = {} as VuetifyPreset\n\n  public userPreset: UserVuetifyPreset = {}\n\n  constructor (userPreset: UserVuetifyPreset = {}) {\n    this.userPreset = userPreset\n\n    this.use(services.Presets)\n    this.use(services.Application)\n    this.use(services.Breakpoint)\n    this.use(services.Goto)\n    this.use(services.Icons)\n    this.use(services.Lang)\n    this.use(services.Theme)\n  }\n\n  // Called on the new vuetify instance\n  // bootstrap in install beforeCreate\n  // Exposes ssrContext if available\n  init (root: Vue, ssrContext?: object) {\n    this.installed.forEach(property => {\n      const service = this.framework[property]\n\n      service.framework = this.framework\n\n      service.init(root, ssrContext)\n    })\n\n    // rtl is not installed and\n    // will never be called by\n    // the init process\n    this.framework.rtl = Boolean(this.preset.rtl) as any\n  }\n\n  // Instantiate a VuetifyService\n  use (Service: VuetifyService) {\n    const property = Service.property\n\n    if (this.installed.includes(property)) return\n\n    // TODO maybe a specific type for arg 2?\n    this.framework[property] = new Service(this.preset, this as any)\n    this.installed.push(property)\n  }\n}\n","import { VNodeDirective } from 'vue/types/vnode'\nimport { DirectiveOptions } from 'vue'\n\ninterface ScrollVNodeDirective extends Omit<VNodeDirective, 'modifiers'> {\n  value: EventListener | {\n    handler: EventListener\n    options?: boolean | AddEventListenerOptions\n  } | EventListenerObject & { options?: boolean | AddEventListenerOptions }\n  modifiers?: {\n    self?: boolean\n  }\n}\n\nfunction inserted (el: HTMLElement, binding: ScrollVNodeDirective) {\n  const { self = false } = binding.modifiers || {}\n  const value = binding.value\n  const options = (typeof value === 'object' && value.options) || { passive: true }\n  const handler = typeof value === 'function' || 'handleEvent' in value ? value : value.handler\n\n  const target = self\n    ? el\n    : binding.arg\n      ? document.querySelector(binding.arg)\n      : window\n\n  if (!target) return\n\n  target.addEventListener('scroll', handler, options)\n\n  el._onScroll = {\n    handler,\n    options,\n    // Don't reference self\n    target: self ? undefined : target,\n  }\n}\n\nfunction unbind (el: HTMLElement) {\n  if (!el._onScroll) return\n\n  const { handler, options, target = el } = el._onScroll\n\n  target.removeEventListener('scroll', handler, options)\n  delete el._onScroll\n}\n\nexport const Scroll = {\n  inserted,\n  unbind,\n} as DirectiveOptions\n\nexport default Scroll\n"],"sourceRoot":""}